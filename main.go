package main

import (
	"os"
	"syscall"

	"github.com/docopt/docopt-go"
	"github.com/kovetskiy/lorg"
)

var (
	version = "1.0"
	usage   = `http-soul ` + version + `

http-soul summoned for help with testing software which should do http requests
to http servers.

  http-soul listens specified address and runs specified program on every
http request, program should serve that *http* request and output http
response like as following:

	HTTP/1.1 200 OK
	Connection: Close
	CustomHeader: Test


	response body

  Note, you doesn't have to write all headers, you should write only additional
http headers, because http-soul will automaticaly create all other standard
http headers, there is one important rule: after headers you should write two
line-breaks, if you want to send custom http status, then you must write it at
the first line.

  For your usability purposes http-soul will create temporary directory for
every request with following structure:
.
├── _id          # unique identifier (generated by http-soul)
├── raw          # raw request
├── method       # request method in uppercase
├── host         # request host from Host: header
├── uri
│   ├── raw      # raw request URI
│   ├── path     # URI path without query
│   ├── query    # URI query without path
│   └── fields   # URI form fields in 'key=value' format
├── headers
│   ├── raw      # raw request headers
│   └── fields   # request headers in 'key=value' format
├── cookies
│   ├── raw      # raw request cookies value
│   └── fields   # request cookies in 'key=value' format
└── body
    ├── raw      # raw request body
    └── fields   # request form fields in 'key=value' format

  http-soul will pass path to directory with request details as argument to
specified program.

  After running http-soul you doesn't have to guess 'does it listening now?',
because http-soul will fork when starts listening for a http connections,
return fork pid and exit with zero code.

Usage:
	http-soul [options] -l <address> -e <path>
	http-soul -h | --help
	http-soul --version

Options:
    -l <address>  Listen specified address.
    -e <path>     Run specified program on every request.
    -o <path>     Output logs to specified file. [default: /dev/stderr]
    -h --help     Show this screen.
    --version     Show version.
`
)

const (
	ListeningStartedSignal = syscall.SIGUSR1
)

var (
	logger = getLogger()
)

func main() {
	args, err := docopt.Parse(usage, nil, true, version, true, true)
	if err != nil {
		panic(err)
	}

	master := true
	if len(os.Getenv("HTTP_SOUL_MASTER")) > 0 {
		master = false
		for i := 0; i < getMaxFD(); i++ {
			syscall.Close(i)
		}
	}

	log, err := os.OpenFile(
		args["-o"].(string),
		os.O_WRONLY|os.O_CREATE|os.O_APPEND,
		0644,
	)
	if err != nil {
		logger.Fatalf("can't open: %s", err)
	}

	logger.SetOutput(log)

	switch master {
	case true:
		logger.SetFormat(lorg.NewFormat(masterFormat))
		masterFlow()

	case false:
		logger.SetFormat(lorg.NewFormat(forkFormat))
		forkFlow(args)
	}
}
